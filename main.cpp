//
//  main.cpp
//
//  Created by Sayan Mandal
//  Copyright Â© 2017 Sayan Mandal. All rights reserved.
//
/*
*/
#include "Collapse.hpp"
// #include "Constants.hpp"
#include "GIC.hpp"
#include "Wrappers/GICWrapper.hpp"
#include "Graphs/KNN_Graph.hpp"
#include "Graphs/NormalGraph.hpp"
#include "MortonCode.hpp"
#include "RandomHomology.hpp"
#include "Wrappers/SimPersWrapper.hpp"
#include "Utilities.hpp"
#include <ctime>
#include <iostream>
#include <vector>
#include <boost/filesystem/operations.hpp>
#include <boost/filesystem/path.hpp>
#include <boost/filesystem.hpp>
#include <boost/thread.hpp>
#include <string>
#include <boost/program_options.hpp>
#include <cstdio>

using std::cout;
using std::endl;
using std::string;
//using std::priority_queue;
using std::vector;

/***********************************************/
string strLicense = "THIS SOFTWARE IS PROVIDED \"AS-IS\". THERE IS NO WARRANTY OF ANY KIND. "
"NEITHER THE AUTHORS NOR THE OHIO STATE UNIVERSITY WILL BE LIABLE FOR "
"ANY DAMAGES OF ANY KIND, EVEN IF ADVISED OF SUCH POSSIBILITY. \n"
"\n"
"This software was developed (and is copyrighted by) the Jyamiti group at "
"The Ohio State University. Please do not redistribute this software. "
"This program is for academic research use only. This software uses the "
"Boost library (www.boost.org) "
"which is covered under their own licenses.\n"
"\n"
"The Boost library's license "
"(which applies to the Boost library ONLY and NOT to this program itself) is "
"as follows:\n"
"\n"
"LICENSE\n"
"---------------------------------------------------------------------------\n"
"Boost Software License - Version 1.0 - August 17th, 2003\n"
"\n"
"Permission is hereby granted, free of charge, to any person or organization "
"obtaining a copy of the software and accompanying documentation covered by "
"this license (the \"Software\") to use, reproduce, display, distribute, "
"execute, and transmit the Software, and to prepare derivative works of the "
"Software, and to permit third-parties to whom the Software is furnished to "
"do so, all subject to the following: \n"
"\n"
"The copyright notices in the Software and this entire statement, including "
"the above license grant, this restriction and the following disclaimer, "
"must be included in all copies of the Software, in whole or in part, and "
"all derivative works of the Software, unless such copies or derivative "
"works are solely in the form of machine-executable object code generated by "
"a source language processor. \n"
"\n"
"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR "
"IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, "
"FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT "
"SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE "
"FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, "
"ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER "
"DEALINGS IN THE SOFTWARE. \n"
"---------------------------------------------------------------------------\n";
/**********************************************************************/

// TODO: set default values
bool ParseCommand(int argc, char* argv[], string &input_points_file, int &max_dim, int &neighbors, float &subsample)
{
	try
	{
		// Define the program options description
		namespace po = boost::program_options;
		po::options_description desc("SiBaCo Usage");
		desc.add_options()
			(",h", "Help information;")
			(",l", "License information;")
			(",n", po::value<int>(&neighbors)->default_value(12), "The number of nearest neighbours to create the intial graph. Default 12")
			(",i", po::value<std::string>(&input_points_file)->default_value(""), "The file name for the initial simplicial complex, containing points in R^d")
			(",m", po::value<int>(&max_dim)->default_value(2), "The maximum dimension the user wants to see in the output persistent barcodes (betti no.). Default is 2")
			(",s", po::value<float>(&subsample)->default_value(5), "The subsample ratio to choose in subsequent collapse operations. Chooses every sth datapoint in the Octree ordering");
			
		// Parser map
		po::variables_map vm;
		try
		{
			po::store(po::parse_command_line(argc, argv, desc), vm);

			//
			if (vm.count("-h"))
			{
				cout << desc << std::endl;
				exit(EXIT_SUCCESS);
			}
			//
			if (vm.count("-l"))
			{
				cout << strLicense << std::endl;
				exit(EXIT_SUCCESS);
			}
			//
			po::notify(vm);
		}
		catch (boost::program_options::required_option& e)
		{
			std::cerr << "ERROR: " << e.what() << std::endl;
			return false;
		}
		catch (boost::program_options::error& e)
		{
			std::cerr << "ERROR: " << e.what() << std::endl;
			return false;
		}
	}
	catch (std::exception& e)
	{
		std::cerr << "Unhandled Exception reached the top of main: "
			<< e.what() << ", application will now exit" << std::endl;
		return false;

	}
	return true;
}

int main(int argc,  char * argv[]) 
{

	    

    string input_points_file;       // = "/Users/billvarcho/Documents/models/kitten.txt";
    int max_dim,neighbors;
    float subsample;


    ParseCommand(argc, argv, input_points_file, max_dim, neighbors, subsample);
    //cout<<"Enter file Name\n";
    //cin>>input_points_file;
    ifstream f(input_points_file.c_str());
    if( f.good()==false)
    {
        cout<<"File does not exist. Use -h for options";
        return 0;
    }
    vector<string> strs;
    boost::split(strs, input_points_file, boost::is_any_of("."));
    string dir_file = strs[0];

    boost::filesystem::path dir(dir_file);
    if (!boost::filesystem::exists(dir_file)) {
        // create directory
        if(! boost::filesystem::create_directory(dir)) {
            cout << "Could not create output directory: FAILED" << endl;
            return 0;
        }
    }
    
    // split
    vector<string> dir_strings;
    boost::split(dir_strings, dir_file, boost::is_any_of("/"));
    string points_name = dir_strings[dir_strings.size() - 1];

    string complex_file = dir_file + "/" + points_name + "_complex.txt";
    string output_collapses = dir_file + "/" + points_name;
    //cout<<"\nEnter Output Dimension of the data\n";

    if(max_dim<1)
    	{cout<<"Maximum Dimension of persistent barcode needs to be greater than 1: FAILED";	return 0;}
    if(subsample<2)
    	{cout<<"Subsampling jump chosen for the subsequent collapse operations need to be greater than 2: FAILED";	return 0;}
    

    cout<<"\ngetting into GIC ss:"<<subsample<<" max_dim: "<<max_dim<<" neighbors: ";

    const clock_t begin_time = clock();
    GICWrapper::Run(input_points_file, complex_file, max_dim, neighbors);
    

    f.close();
    GIC g(complex_file);
    fflush(stdin);
    cout<<"Out of GIC\n";
    //getchar();
    vector<Operation*> collapses;
    RandomHomology r(g);
    r.run(subsample, input_points_file, collapses);
    cout << "\nCollapse with GIC Total Timing without I/O:" <<float( clock () - begin_time ) /  CLOCKS_PER_SEC<<endl;
    Utilities::WriteCollapsesToFile(output_collapses, collapses);
    cout << "\nCollapse with GIC Total Timing :" <<float( clock () - begin_time ) /  CLOCKS_PER_SEC<<endl;

    SimpersWrapper::Run( collapses, output_collapses);
    cout << "\n\nTotal Running Time:" <<float( clock () - begin_time ) /  CLOCKS_PER_SEC<<endl;
    // cou
    unlink(output_collapses.c_str());
    unlink(complex_file.c_str());
    string idc = dir_file + "/" + points_name+"_iDC";

    unlink(idc.c_str());
    idc = dir_file + "/" + points_name+"_collapses";
    unlink(idc.c_str());

    return 1;
}
